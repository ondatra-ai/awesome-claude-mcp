# Story 1.2: AWS Infrastructure Setup

## Status
Approved

## Story
**As a** Developer/Maintainer,
**I want** to configure AWS infrastructure,
**so that** I have a deployable environment for the application

## Acceptance Criteria
1. AWS account configured with appropriate IAM roles
2. ECS Fargate cluster created and configured
3. Application Load Balancer configured with proper target groups
4. VPC and networking configured for container communication
5. CloudWatch logging enabled for all services
6. Infrastructure defined in Terraform
7. Deployment successful to AWS ECS

## Tasks / Subtasks

Note: All infrastructure Create/Configure items below must be implemented via Terraform modules and applied per environment (dev → staging → prod).

- [ ] Task 1: AWS Account and IAM Setup (AC: 1)
  - [ ] Configure AWS account with appropriate permissions
  - [ ] Create IAM roles for ECS tasks and services
  - [ ] Set up IAM policies for service communication and AWS resource access
  - [ ] Configure IAM roles for CloudWatch logging and monitoring
  - [ ] Create service-linked roles for ECS and ALB
  - [ ] Verify IAM role trust relationships and permissions

- [ ] Task 2: VPC and Networking Infrastructure (AC: 4)
  - [ ] Create VPC with public and private subnets across multiple AZs
  - [ ] Configure Internet Gateway for public subnet access
  - [ ] Set up NAT Gateways for private subnet outbound traffic
  - [ ] Configure route tables for public and private subnets
  - [ ] Create security groups for ECS services and ALB
  - [ ] Configure network ACLs for additional security
  - [ ] Test network connectivity between subnets

- [ ] Task 3: ECS Fargate Cluster Configuration (AC: 2)
  - [ ] Create ECS cluster with Fargate launch type
  - [ ] Configure cluster capacity providers for Fargate
  - [ ] Set up ECS task definitions for all three services
  - [ ] Configure ECS services with desired count and placement strategies
  - [ ] Set up auto scaling policies for ECS services
  - [ ] Configure service discovery using AWS Cloud Map
  - [ ] Test ECS service deployment and scaling

- [ ] Task 4: Application Load Balancer Setup (AC: 3)
  - [ ] Create Application Load Balancer in public subnets
  - [ ] Configure target groups for frontend and backend services
  - [ ] Set up health check configurations for target groups
  - [ ] Configure ALB listeners and routing rules
  - [ ] Set up SSL/TLS termination with ACM certificates
  - [ ] Configure sticky sessions if required
  - [ ] Test load balancer routing and health checks

- [ ] Task 5: CloudWatch Logging and Monitoring (AC: 5)
  - [ ] Create CloudWatch Log Groups for all services
  - [ ] Configure ECS task definitions with CloudWatch log driver
  - [ ] Set up log retention policies
  - [ ] Create CloudWatch dashboards for service monitoring
  - [ ] Configure CloudWatch alarms for service health
  - [ ] Set up CloudWatch Insights for log analysis
  - [ ] Test log collection and monitoring capabilities

- [ ] Task 6: Terraform Infrastructure as Code (AC: 6)
  - [ ] Create Terraform module structure for AWS resources
  - [ ] Define VPC and networking resources in Terraform
  - [ ] Configure ECS cluster and services in Terraform
  - [ ] Set up ALB and target groups in Terraform
  - [ ] Define CloudWatch logging/monitoring resources in Terraform
  - [ ] Create ECR repositories for frontend, backend, and mcp-service images
  - [ ] Provision ElastiCache Redis cluster in private subnets
  - [ ] Create environment directories under `infrastructure/terraform/environments/{dev,staging,prod}` with tfvars
  - [ ] Create Terraform variables and outputs
  - [ ] Validate Terraform configuration and plan

- [ ] Task 7: Deployment and Integration Testing (AC: 7)
  - [ ] Deploy infrastructure using Terraform
  - [ ] Build and push Docker images to ECR
  - [ ] Deploy all services to ECS cluster
  - [ ] Verify service communication through ALB
  - [ ] Test health check endpoints
  - [ ] Validate CloudWatch logging functionality
  - [ ] Perform end-to-end deployment validation

## Dev Notes

### Previous Story Insights
From Story 1.1, we have established:
- Complete Docker containerization with multi-stage builds
- Three-service architecture: Frontend (Next.js), Backend (Go Fiber), MCP Service (Mark3Labs)
- Health check endpoints implemented for all services
- Docker Compose working for local development
- Service-to-service communication patterns established

### Data Models
No specific data models required for infrastructure setup. Infrastructure will support the document operation data models from the MCP service.

### API Specifications
**Infrastructure Endpoints:** [Source: architecture/tech-stack.md#aws-infrastructure]
- ALB health check endpoints for all services
- ECS service discovery endpoints
- CloudWatch metrics endpoints

**Service Communication:**
- Frontend → Backend: HTTP via ALB
- Backend → MCP Service: Internal ECS service discovery
- All services → CloudWatch: Log streaming

### Component Specifications
**AWS Infrastructure Components:** [Source: architecture/tech-stack.md#aws-infrastructure]
- **ECS Fargate Cluster**: Container orchestration platform
  - Cluster: mcp-google-docs-editor-cluster
  - Services: frontend-service, backend-service, mcp-service
  - Task definitions with 0.25 vCPU, 512 MB memory allocation
- **Application Load Balancer**: Traffic routing and SSL termination
  - Internet-facing ALB with SSL/TLS certificates
  - Target groups for frontend (port 3000) and backend (port 8080)
  - Health check paths: / (frontend), /health (backend)
- **ElastiCache Redis**: Session storage and caching layer
  - Redis 7.0 cluster mode for high availability
  - VPC-only access with encryption in transit
- **CloudWatch**: Comprehensive logging and monitoring
  - Log groups per service with 30-day retention
  - Custom metrics for application performance

### File Locations
**Terraform Infrastructure:** [Source: architecture/source-tree.md#infrastructure]
- Root module: `infrastructure/terraform/`
- VPC module: `infrastructure/terraform/modules/vpc/`
- ECS module: `infrastructure/terraform/modules/ecs/`
- ALB module: `infrastructure/terraform/modules/alb/`
- ECR module: `infrastructure/terraform/modules/ecr/`
- Redis module: `infrastructure/terraform/modules/redis/`
- Variables: `infrastructure/terraform/variables.tf`
- Outputs: `infrastructure/terraform/outputs.tf`
 - Environments: `infrastructure/terraform/environments/{dev,staging,prod}/`

**Docker Images:**
- Frontend: Built from `services/frontend/Dockerfile`
- Backend: Built from `services/backend/Dockerfile`
- Images pushed to ECR repositories

**Configuration Files:**
- Terraform: `infrastructure/terraform/*.tf`
- AWS CLI config: `~/.aws/config`
- Environment variables: Service-specific env files

### Testing Requirements
**Infrastructure Testing:** [Source: architecture/coding-standards.md#testing-standards]
- Terraform validation: `terraform validate`
- Infrastructure plan verification: `terraform plan`
- Resource deployment testing: `terraform apply`
- End-to-end deployment validation
- Load balancer health check verification
- Service communication testing through ALB

**AWS Testing Tools:**
- AWS CLI for resource verification
- Terraform for infrastructure validation
- ECS CLI for service deployment testing
- CloudWatch for monitoring validation

**Validation Checklist:**
- All services deployed and healthy in ECS
- ALB routing correctly to services
- CloudWatch logs streaming from all services
- Security groups allowing proper traffic flow
- Auto scaling policies functioning correctly

### Technical Constraints
**AWS Infrastructure:** [Source: architecture/tech-stack.md#aws-infrastructure]
- **ECS Fargate**: Latest platform version with 0.25 vCPU, 512 MB memory per task
- **Application Load Balancer**: Internet-facing with SSL termination
- **VPC**: Multi-AZ setup with public and private subnets
- **ElastiCache**: Redis 7.0 cluster mode with encryption
- **CloudWatch**: Structured JSON logging with 30-day retention
- **Terraform**: Version 1.6+ for infrastructure as code

**Networking Constraints:** [Source: architecture/tech-stack.md]
- Frontend accessible via ALB (port 80/443)
- Backend accessible via ALB (port 80/443 with /api prefix)
- MCP service internal only (ECS service discovery)
- Redis accessible only within VPC private subnets
- All outbound traffic through NAT Gateways

**Security Constraints:**
- All services run in private subnets
- Internet access only through ALB
- IAM roles with least privilege principles
- Security groups with minimal required access
- Encrypted data in transit and at rest

### Testing
**Test File Locations:** [Source: architecture/source-tree.md]
- Infrastructure tests: `infrastructure/tests/`
- Terraform validation: `infrastructure/terraform/`
- Deployment scripts: `scripts/deploy/`

**Testing Standards:**
- Terraform validation before apply
- Infrastructure smoke tests after deployment
- Service health checks validation
- Load balancer routing verification
- CloudWatch logging validation

**Testing Tools:**
- Terraform built-in validation
- AWS CLI for resource verification
- Custom deployment scripts for validation
- CloudWatch for monitoring validation

**Validation Requirements:**
- All Terraform configurations valid
- All AWS resources created successfully
- Services deployed and running in ECS
- Load balancer health checks passing
- CloudWatch logs receiving data from all services

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-10 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
Story creation started 2025-09-10

### Completion Notes List
- Story 1.2 drafted following create-next-story task workflow
- Incorporated technical context from Story 1.1 completion
- AWS infrastructure requirements extracted from Epic 1 and tech-stack.md
- Task breakdown aligned with infrastructure deployment best practices
- Ready for Product Owner validation and implementation planning

### File List
<!-- Populate during development: list created/modified/deleted files -->

## QA Results
<!-- QA Agent will append results after implementation review -->
